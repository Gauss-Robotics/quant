from __future__ import annotations
import numpy
import quantpy.quantpy.units
import typing
__all__ = ['AngularAcceleration', 'LinearAcceleration']
class AngularAcceleration:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    def radians_per_second_squared(arg0: numpy.ndarray[tuple[typing.Literal[4], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> AngularAcceleration:
        ...
    @staticmethod
    def zero() -> AngularAcceleration:
        ...
    def __eq__(self, arg0: AngularAcceleration) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __ne__(self, arg0: AngularAcceleration) -> bool:
        ...
    def to_radians_per_second_squared(self) -> quantpy.quantpy.units.AxisAngle:
        ...
class LinearAcceleration:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    def meters_per_second_squared(arg0: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> LinearAcceleration:
        ...
    @staticmethod
    def millimeters_per_second_squared(arg0: numpy.ndarray[tuple[typing.Literal[3], typing.Literal[1]], numpy.dtype[numpy.float64]]) -> LinearAcceleration:
        ...
    @staticmethod
    def zero() -> LinearAcceleration:
        ...
    def __eq__(self, arg0: LinearAcceleration) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __ne__(self, arg0: LinearAcceleration) -> bool:
        ...
    def to_meters_per_second_squared(self) -> quantpy.quantpy.units.Vector:
        ...
    def to_millimeters_per_second_squared(self) -> quantpy.quantpy.units.Vector:
        ...
