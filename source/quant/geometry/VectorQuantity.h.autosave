#pragma once

#include <quant/geometry/Difference.h>
#include <quant/geometry/Vector.h>
#include <quant/geometry/detail/Accessors.h>

#include <Eigen/Geometry>

#include <ostream>
#include <typeinfo>

namespace quant::geometry
{

    template <typename BaseQuantityT>
    class VectorQuantity
    {
    public:
        // Construct.

        VectorQuantity() : representation_(0, 0, 0)
        {
            ;
        }

        VectorQuantity(Difference<BaseQuantityT> const& deltaP) :
            VectorQuantity(deltaP.differenceObject_)
        {
            ;  // TODO(dreher): Does this overload make sense? No Difference here if possible
        }

        static BaseQuantityT
        Origin()
        {
            return BaseQuantityT(0, 0, 0);
        }

        // Convert.

        std::string
        toString(std::string const& quantityName = "", std::string const& unit = "") const
        {
            std::stringstream out;
            out << "<";

            if (not quantityName.empty())
            {
                out << quantityName << " ";
            }

            out << toVector().toString(unit) << ">";
            return out.str();
        }

        // Compare.

        bool
        operator==(BaseQuantityT const& rhs) const
        {
            return representation_ == rhs.representation_;
        }

        bool
        operator!=(BaseQuantityT const& rhs) const
        {
            return representation_ != rhs.representation_;
        }

        bool
        isApprox(BaseQuantityT const& rhs, double precision) const
        {
            return representation_.isApprox(rhs.representation_, precision);
        }

        using Representation = Eigen::Ref<Eigen::Vector3d const>;

    public:  // TODO(dreher): Make protected.
        Eigen::Vector3d representation_;

    protected:
        // Construct.

        VectorQuantity(double x, double y, double z) : representation_(x, y, z)
        {
            ;
        }

        VectorQuantity(Vector const& xyz) : representation_(xyz.x, xyz.y, xyz.z)
        {
            ;
        }

        VectorQuantity(Eigen::Ref<Eigen::Vector3d const> vector) : representation_(vector)
        {
            ;
        }

        // Convert.

        Vector
        toVector() const
        {
            return Vector::FromEigen(representation_);
        }

        friend class detail::Accessor<BaseQuantityT>;
    };

    class LinearDifference;

    class LinearQuantity
    {
    public:
        LinearQuantity() : representation_{0, 0, 0}
        {
            ;
        }
        
    protected:
        Eigen::Vector3d representation_;
    };

}  // namespace quant::geometry
